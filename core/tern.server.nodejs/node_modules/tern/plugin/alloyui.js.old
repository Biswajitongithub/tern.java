(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/comment"),
               require("acorn/util/walk"), require("acorn/acorn"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/comment", "acorn/util/walk", "acorn/acorn"], mod);
  mod(tern, tern, tern.comment, acorn.walk, acorn);
})(function(infer, tern, comment, walk, acorn) {
  "use strict";

  var SetDoc = infer.constraint("doc", {
    addType: function(type) {
      if (!type.doc) type.doc = this.doc;
    }
  });

  function Injector() {
    this.fields = Object.create(null);
    this.forward = [];
  }

  Injector.prototype.get = function(name) {
    if (name == "$scope") return new infer.Obj(globalInclude("$rootScope").getType(), "$scope");
    if (name in this.fields) return this.fields[name];
    var field = this.fields[name] = new infer.AVal;
    return field;
  };
  Injector.prototype.set = function(name, val, doc, node, depth, fieldType) {
    if (name == "$scope" || depth && depth > 10) return;
    var field = this.fields[name] || (this.fields[name] = new infer.AVal);
    if (!depth) field.local = true;
    field.type = fieldType;
    field.fnType = val.fnType;
    if (!field.origin) field.origin = infer.cx().curOrigin;
    if (typeof node == "string" && !field.span) field.span = node;
    else if (node && typeof node == "object" && !field.originNode) field.originNode = node;
    if (doc) { field.doc = doc; field.propagate(new SetDoc(doc)); }
    val.propagate(field);
    for (var i = 0; i < this.forward.length; ++i)
      this.forward[i].set(name, val, doc, node, (depth || 0) + 1);
  };
  Injector.prototype.forwardTo = function(injector) {
    this.forward.push(injector);
    for (var field in this.fields) {
      var val = this.fields[field];
      injector.set(field, val, val.doc, val.span || val.originNode, 1);
    }
  };

  function globalInclude(name) {
    var service = infer.cx().definitions.angular.service;
    if (service.hasProp(name)) return service.getProp(name);
  }

  function getInclude(mod, name) {
    var glob = globalInclude(name);
    if (glob) return glob;
    if (!mod.injector) return infer.ANull;
    return mod.injector ? mod.injector.get(name) : infer.ANull;
  }

  function applyWithInjection(mod, fnType, node, asNew) {
    var deps = [];
    if (node.type == "FunctionExpression") {
      for (var i = 0; i < node.params.length; ++i)
        deps.push(getInclude(mod, node.params[i].name));
    } else if (node.type == "ArrayExpression") {
      for (var i = 0; i < node.elements.length - 1; ++i) {
        var elt = node.elements[i];
        if (elt.type == "Literal" && typeof elt.value == "string")
          deps.push(getInclude(mod, elt.value));
        else
          deps.push(infer.ANull);
      }
      var last = node.elements[node.elements.length - 1];
      if (last && last.type == "FunctionExpression")
        fnType = last.body.scope.fnType;
    }
    var result = new infer.AVal;
    if (asNew) {
      var self = new infer.AVal;
      fnType.propagate(new infer.IsCtor(self));
      self.propagate(result, 90);
      fnType.propagate(new infer.IsCallee(self, deps, null, new infer.IfObj(result)));
    } else {
      fnType.propagate(new infer.IsCallee(infer.cx().topScope, deps, null, result));
    }
    result.fnType = fnType;
    return result;
  }

  infer.registerFunction("angular_callInject", function(argN) {
    return function(self, args, argNodes) {
      var mod = self.getType();
      if (mod && argNodes && argNodes[argN])
        applyWithInjection(mod, args[argN], argNodes[argN]);
        if (args[argN].argNames && args[argN].argNames[0] == '$rootScope') {
          mod.rootScope = args[argN].args[0];
        }
    };
  });

  infer.registerFunction("angular_regFieldCallController", function(self, args, argNodes) {
    angular_regFieldCall(self, args, argNodes, 'controller')
  });

  infer.registerFunction("angular_regFieldCallDirective", function(self, args, argNodes) {
    var mod = self.getType(), fn = null;
    if (mod && argNodes && argNodes.length > 1) {
      var retval = args[1].retval;
      if (retval) {
        var type = retval.getType();
        if (type && type.props && type.props.controller && type.props.controller.getType()) {
          var fn = args[1].retval.getType().props.controller.getType();
          var node = fn.originNode;        
          
          var result = applyWithInjection(mod, fn, node);
          if (mod.injector && argNodes[0].type == "Literal")
            mod.injector.set(argNodes[0].value + '#controller', result, argNodes[0].angularDoc, argNodes[0], null, 'controller');
          
          fn = args[1].retval.getType();
        }
      }
      
      if (!mod.directives) mod.directives = {};
      mod.directives[argNodes[0].value] = {"originNode": argNodes[0], "type" : fn};
    }
  });
  
  infer.registerFunction("angular_regFieldCall", function(self, args, argNodes) {
    angular_regFieldCall(self, args, argNodes);
  });
  
  function angular_regFieldCall(self, args, argNodes, callType) {
    var mod = self.getType();
    if (mod && argNodes && argNodes.length > 1) {
      var result = applyWithInjection(mod, args[1], argNodes[1]);
      if (mod.injector && argNodes[0].type == "Literal")
        mod.injector.set(argNodes[0].value, result, argNodes[0].angularDoc, argNodes[0], null, callType);
    }
  };

  infer.registerFunction("angular_regFieldNew", function(self, args, argNodes) {
    var mod = self.getType();
    if (mod && argNodes && argNodes.length > 1) {
      var result = applyWithInjection(mod, args[1], argNodes[1], true);
      if (mod.injector && argNodes[0].type == "Literal")
        mod.injector.set(argNodes[0].value, result, argNodes[0].angularDoc, argNodes[0]);
    }
  });

  infer.registerFunction("angular_regField", function(self, args, argNodes) {
    var mod = self.getType();
    if (mod && mod.injector && argNodes && argNodes[0] && argNodes[0].type == "Literal" && args[1])
      mod.injector.set(argNodes[0].value, args[1], argNodes[0].angularDoc, argNodes[0]);
  });
  
  infer.registerFunction("angular_callFilter", function(self, args, argNodes) {
    var mod = self.getType();
    if (mod && argNodes && argNodes[0] && argNodes[0].type == "Literal") {
      if (!mod.filters) mod.filters = {};
      mod.filters[argNodes[0].value] = {"originNode": argNodes[0], "fnType" : argNodes[1]};
    }
  });
  
  infer.registerFunction("angular_callFactory", function(self, args, argNodes) {
    var mod = self.getType();
    if (mod && argNodes && argNodes.length > 1) {
      var result = applyWithInjection(mod, args[1], argNodes[1]);
      if (mod.injector && argNodes[0].type == "Literal") {
        mod.injector.set(argNodes[0].value, result, argNodes[0].angularDoc, argNodes[0], null);
        if (!mod.factories) mod.factories = {};
        mod.factories[argNodes[0].value] = {"originNode": argNodes[0]};
      }
    }
  });
  
  infer.registerFunction("angular_callProvider", function(self, args, argNodes) {
    var mod = self.getType();
    if (mod && argNodes && argNodes.length > 1) {
      var result = applyWithInjection(mod, args[1], argNodes[1]);
      if (mod.injector && argNodes[0].type == "Literal") {
        mod.injector.set(argNodes[0].value, result, argNodes[0].angularDoc, argNodes[0], null);
        if (!mod.providers) mod.providers = {};
        mod.providers[argNodes[0].value] = {"originNode": argNodes[0]};
      }
    }
  });

  infer.registerFunction("angular_callService", function(self, args, argNodes) {
    var mod = self.getType();
    if (mod && argNodes && argNodes.length > 1) {
      var result = applyWithInjection(mod, args[1], argNodes[1], true);
      if (mod.injector && argNodes[0].type == "Literal")
        mod.injector.set(argNodes[0].value, result, argNodes[0].angularDoc, argNodes[0]);
      if (!mod.services) mod.services = {};
      mod.services[argNodes[0].value] = {"originNode": argNodes[0]};
    }
  });
  
  function arrayNodeToStrings(node) {
    var strings = [];
    if (node && node.type == "ArrayExpression")
      for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt.type == "Literal" && typeof elt.value == "string")
          strings.push(elt.value);
      }
    return strings;
  }

  function moduleProto(cx) {
    var ngDefs = cx.definitions.angular;
    return ngDefs && ngDefs.Module.getProp("prototype").getType();
  }

  function declareMod(name, includes, originNode) {
    var cx = infer.cx(), data = cx.parent._angular;
    var proto = moduleProto(cx);
    var mod = new infer.Obj(proto || true);
    if (!proto) data.nakedModules.push(mod);
    mod.origin = cx.curOrigin;
    mod.originNode = originNode;
    mod.injector = new Injector();
    mod.metaData = {includes: includes};
    for (var i = 0; i < includes.length; ++i) {
      var depMod = data.modules[includes[i]];
      if (!depMod)
        (data.pendingImports[includes[i]] || (data.pendingImports[includes[i]] = [])).push(mod.injector);
      else if (depMod.injector)
        depMod.injector.forwardTo(mod.injector);
    }
    if (typeof name == "string") {
      data.modules[name] = mod;
      var pending = data.pendingImports[name];
      if (pending) {
        delete data.pendingImports[name];
        for (var i = 0; i < pending.length; ++i)
          mod.injector.forwardTo(pending[i]);
      }
    }
    return mod;
  }

  infer.registerFunction("angular_module", function(_self, _args, argNodes) {
    var mod, name = argNodes && argNodes[0] && argNodes[0].type == "Literal" && argNodes[0].value;
    if (typeof name == "string")
      mod = infer.cx().parent._angular.modules[name];
    if (!mod)
      mod = declareMod(name, arrayNodeToStrings(argNodes && argNodes[1]), argNodes[0]);
    return mod;
  });

  var IsBound = infer.constraint("self, args, target", {
    addType: function(tp) {
      if (!(tp instanceof infer.Fn)) return;
      this.target.addType(new infer.Fn(tp.name, tp.self, tp.args.slice(this.args.length),
                                       tp.argNames.slice(this.args.length), tp.retval));
      this.self.propagate(tp.self);
      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
        this.args[i].propagate(tp.args[i]);
    }
  });

  infer.registerFunction("angular_bind", function(_self, args) {
    if (args.length < 2) return infer.ANull;
    var result = new infer.AVal;
    args[1].propagate(new IsBound(args[0], args.slice(2), result));
    return result;
  });

  function postParse(ast, text) {
    walk.simple(ast, {
      CallExpression: function(node) {
        if (node.callee.type == "MemberExpression" &&
            !node.callee.computed && node.arguments.length &&
            /^(value|constant|controller|factory|provider)$/.test(node.callee.property.name)) {
          var before = comment.commentsBefore(text, node.callee.property.start - 1);
          if (before) {
            var first = before[0], dot = first.search(/\.\s/);
            if (dot > 5) first = first.slice(0, dot + 1);
            first = first.trim().replace(/\s*\n\s*\*\s*|\s{1,}/g, " ");
            node.arguments[0].angularDoc = first;
          }
        }
      }
    });
  }

  function postLoadDef(json) {
    var cx = infer.cx(), defName = json["!name"], defs = cx.definitions[defName];
    if (defName == "angular") {
      var proto = moduleProto(cx), naked = cx.parent._angular.nakedModules;
      if (proto) for (var i = 0; i < naked.length; ++i) naked[i].proto = proto;
      return;
    }
    var mods = defs && defs["!ng"];
    if (mods) for (var name in mods.props) {
      var obj = mods.props[name].getType();
      var mod = declareMod(name.replace(/`/g, "."), obj.metaData && obj.metaData.includes || []);
      mod.origin = defName;
      for (var prop in obj.props) {
        var val = obj.props[prop], tp = val.getType();
        if (!tp) continue;
        if (/^_inject_/.test(prop)) {
          if (!tp.name) tp.name = prop.slice(8);
          mod.injector.set(prop.slice(8), tp, val.doc, val.span);
        } else {
          obj.props[prop].propagate(mod.defProp(prop));
        }
      }
    }
  }

  function preCondenseReach(state) {
    var mods = infer.cx().parent._angular.modules;
    var modObj = new infer.Obj(null), found = 0;
    for (var name in mods) {
      var mod = mods[name];
      if (state.origins.indexOf(mod.origin) > -1) {
        var propName = name.replace(/\./g, "`");
        modObj.defProp(propName).addType(mod);
        mod.condenseForceInclude = true;
        ++found;
        if (mod.injector) for (var inj in mod.injector.fields) {
          var field = mod.injector.fields[inj];
          if (field.local) state.roots["!ng." + propName + "._inject_" + inj] = field;
        }
      }
    }
    if (found) state.roots["!ng"] = modObj;
  }

  function postCondenseReach(state) {
    var mods = infer.cx().parent._angular.modules;
    for (var path in state.types) {
      var m;
      if (m = path.match(/^!ng\.([^\.]+)\._inject_([^\.]+)^/)) {
        var mod = mods[m[1].replace(/`/g, ".")];
        console.log(mod.injector.fields, m[2]);
        var field = mod.injector.fields[m[2]];
        var data = state.types[path];
        if (field.span) data.span = field.span;
        if (field.doc) data.doc = field.doc;
      }
    }
  }

  function initServer(server) {
    server._angular = {
      modules: Object.create(null),
      pendingImports: Object.create(null),
      nakedModules: []
    };
  }

  tern.registerPlugin("alloyui", function(server) {
    initServer(server);
    server.on("reset", function() { initServer(server); });
    return {defs: defs,
            passes: {postParse: postParse,
                     postLoadDef: postLoadDef,
                     preCondenseReach: preCondenseReach,
                     postCondenseReach: postCondenseReach},
            loadFirst: true};
  });

  var defs = {
    "!name": "alloyui",
    "AUI": {
      "!type": "fn() -> AUI.fn",
      "!url": "http://api.jquery.com/jquery/",
      "!doc": "Return a collection of matched elements either found in the DOM based on passed argument(s) or created by passing an HTML string.",
      "fn": {
        "use": {
          "!type": "fn(selector: string) -> AUI.fn",
          "!url": "http://api.jquery.com/add/",
          "!doc": "Add elements to the set of matched elements."
        }
      }
    }
  };
  
  // Angular query type.
  
  var querySubTypes = {
    completions: {
        run: findCompletions
    },
    definition: {
      run: findDef
    },
    type: {
        run: findType
      }
  }
  
  tern.defineQueryType("angular", {
    run : function(server, query) {
      var subtype = query.subtype;
      if (subtype == null) throw ternError("missing .query.subtype field");
      var angularTypes = query.angularTypes;
      if (angularTypes == null) throw ternError("missing .query.angularTypes field");
      var expression = query.expression;
      if (expression == null) throw ternError("missing .query.expression field");
      var scope = query.scope;
      var _angular = server.cx.parent._angular;
      if (_angular == null) throw ternError("missing server.cx.parent._angular");
      
      var files = [];
      var filesName = query.files;
      if (filesName) {
        for ( var i = 0; i < filesName.length; i++) {
          files.push(server.findFile(filesName[i]));
        }
      }

      return querySubTypes[subtype].run(_angular, files, expression, scope,
          angularTypes, query);
    }
  });
  
  // Utils
  
  function isBelongToFiles(origin, files) {
    for ( var i = 0; i < files.length; i++) {
      if (files[i].name === origin) return true;
    }
    return false;
  }
  
  function startsWithString(str, token) {
    return str.slice(0, token.length).toUpperCase() == token.toUpperCase();
  }
  
  function getType(elt, name) {
    if (elt.props && elt.props[name]) {
      var obj = elt.props[name];
      var type = obj.getType(true);
      if (type) return type;
    }
    var forward = elt.forward;
    if (forward) {
      for ( var i = 0; i < forward.length; i++) {
        var f = forward[i];
        var prop = f.prop;
        if (prop === name) {
          var type = f.type;
          if (type) return type;
        }
      }
    }
  }

  function getArrType(elt, name) {
    if (elt.props && elt.props[name]) {
      var obj = elt.props[name];
      var type = obj.getType(true);
      if (type && type.name == 'Array') {
        return type.getProp("<i>").getType();
      }
    }
    var forward = elt.forward;
    if (forward) {
      for ( var i = 0; i < forward.length; i++) {
        var f = forward[i];
        var prop = f.prop;
        if (prop === name) {
          var type = f.type;
          if (type && type.name == 'Array') {
            var itemType = type.getProp("<i>").getType();
            if (itemType) return itemType;
          }          
        }
      }
    }
  }

  // Angular Modules query
  
  function getModule(_angular, files, moduleName) {
    var module = _angular.modules[moduleName];
    if (module && isBelongToFiles(module.origin, files)) return module;      
  }

  function visitModules(_angular, files, c) {
    for ( var moduleName in _angular.modules) {
      var module = _angular.modules[moduleName];
      if (isBelongToFiles(module.origin, files)) {
        if (c(moduleName, module))
          break;
      }
    }
  }  
  
  // Angular Controllers query  

  function getScopeArg(fnType) {
    if (fnType) {
      var argNames = fnType.argNames;
      if (argNames) {
        var args = fnType.args;
        var arg = null;
        for ( var j = 0; j < argNames.length; j++) {
          if (argNames[j] == "$scope") {
            return args[j];
          }
        }
      }
    }
  }

  function getScopeController(_angular, files, moduleName, controllerName) {
    if (moduleName) {
      var module = getModule(_angular, files, moduleName);
      if (module) {
        var fields = module.injector.fields, field = fields[controllerName];
        if (field && field.type === "controller") {
          var fnType = field.fnType;
          return getScopeArg(fnType);          
        }
      }
    } else {
      var topScope = infer.cx().topScope, props = topScope.props;
      if (props) {
        var item = props[controllerName];
        if (item && isBelongToFiles(item.origin, files) && item.types && item.types.length > 0) {
          for ( var i = 0; i < item.types.length; i++) {
            var fnType = item.types[i], scopeArg = getScopeArg(fnType);
            if (scopeArg) return scopeArg;            
          }          
        }
      }
    }
    return null;
  }
  
  function visitModuleControllers(_angular, files, moduleName, c) {
    var found = false;
    var module = getModule(_angular, files, moduleName);
    if (module) {
      var fields = module.injector.fields;
      for ( var fieldName in fields) {
        var field = fields[fieldName];
        if (field.type === "controller") {
          var fnType = field.fnType;
          var scopeArg = getScopeArg(fnType);
          if (scopeArg) {
            found = true;
            if (c(fieldName, field.originNode, fnType, scopeArg)) break;
          }
        }
      }
    }
    return found;
  }
  
  function visitGlobalControllers(_angular, files, c) {
    var topScope = infer.cx().topScope, stop = false, props = topScope.props;
    if (props) {
      for ( var prop in props) {
        if (prop != "<i>") {
          if (stop)
            break;
          var item = props[prop];
          if (item.types && item.types.length > 0) {
            for ( var i = 0; i < item.types.length; i++) {
              if (stop)
                break;
              var fnType = item.types[i];
              var scopeArg = getScopeArg(fnType);
              if (scopeArg && isBelongToFiles(scopeArg.origin, files)) {
                stop = (c(fnType.name, fnType.originNode.id, fnType,
                    scopeArg));
              }
            }
          }
        }
      }
    }
  }

  function visitControllers(_angular, files, moduleName, c) {
    var found = false;
    if (moduleName) {
      // find controllers of given module
      found = visitModuleControllers(_angular, files, moduleName, c);
    } 
    if (!found) {
      // find global controllers of the given file
      visitGlobalControllers(_angular, files, c);
    }
  }

  // Angular directive query

  function visitDirectives(_angular, files, moduleName, c) {
    if (moduleName) {
      var module = getModule(_angular, files, moduleName);
      if (module) {
        var directives = module.directives;
        if (directives) {
          for ( var name in directives) {
            var directive = directives[name];
            if (c(name, directive.originNode, directive.type)) break;
          }
        }
      }
    }    
  }
  
  // Angular filter query

  function visitFilters(_angular, files, moduleName, c) {
    if (moduleName) {
      var module = getModule(_angular, files, moduleName);
      if (module) {
        var filters = module.filters;
        if (filters) {
          for ( var name in filters) {
            var filter = filters[name];
            if (c(name, filter.originNode, filter.type)) break;
          }
        }
      }
    }    
  }

  // Angular factory query

  function visitFactories(_angular, files, moduleName, c) {
    if (moduleName) {
      var module = getModule(_angular, files, moduleName);
      if (module) {
        var factories = module.factories;
        if (factories) {
          for ( var name in factories) {
            var factory = factories[name];
            if (c(name, factory.originNode, factory.type)) break;
          }
        }
      }
    }    
  }

  // Angular provider query

  function visitProviders(_angular, files, moduleName, c) {
    if (moduleName) {
      var module = getModule(_angular, files, moduleName);
      if (module) {
        var providers = module.providers;
        if (providers) {
          for ( var name in providers) {
            var provider = providers[name];
            if (c(name, provider.originNode, provider.type)) break;
          }
        }
      }
    }    
  }

  // Angular service query

  function visitServices(_angular, files, moduleName, c) {
    if (moduleName) {
      var module = getModule(_angular, files, moduleName);
      if (module) {
        var services = module.services;
        if (services) {
          for ( var name in services) {
            var service = services[name];
            if (c(name, service.originNode, service.type)) break;
          }
        }
      }
    }    
  }
  // Angular model query
  
  function findModels(scopeCtrl, c) {
          if (scopeCtrl) {
                  var forward = scopeCtrl.forward;
                  if (forward) {
                          for ( var i = 0; i < forward.length; i++) {
                                if (c(forward[i])) break;                               
                        }
                  }
          }
  }  
  
  function maybeSet(obj, prop, val) {
    if (val != null) obj[prop] = val;
  }
  
  function findCompletions(_angular, files, expression, scope, angularTypes,
      query) {
    var completions = [];
    var result = {
      "completions" : completions
    }

    var word = '', current = '', context = null;
    var length = expression.length;
    for ( var i = length - 1; i >= 0; i--) {
      if (acorn.isIdentifierChar(expression.charCodeAt(i)))
        current = expression.charAt(i) + current;
      else if (expression.charAt(i) === '.') {
        if (context)
          context.unshift(current);
        else {
          word = current;
          context = [];
        }
        current = '';
      } else {
        break;
      }
    }
    if (context)
      context.unshift(current);
    else
      word = current;
    var end = expression.length, start = end - word.length;
    result.start = start;
    result.end = end;

    if (query.caseInsensitive) word = word.toLowerCase();
    var wrapAsObjs = true;//query.types || query.depths || query.docs || query.urls || query.origins;
    
    function createCompletionIfMatch(prop, obj, module, angularType) {
      if (startsWithString(prop, word)) {
        var completion = createCompletion(prop, obj, scope, query, module, angularType);
        completions.push(completion);
        return completion;
      }
    }

    function completionDirectives(_angular, files, moduleName) {
      visitDirectives(_angular, files, moduleName, function(name, node,
          fnType) {
        var completion = createCompletionIfMatch(name, fnType, moduleName, 'directive')
        if (completion && fnType.originNode && fnType.originNode.properties) {
          var properties = fnType.originNode.properties;
          for ( var i = 0; i < properties.length; i++) {
            var p = properties[i];
            if (p.key.name === 'restrict' && p.value.type === 'Literal') {
              completion.restrict = p.value.value;
            }
          }
        }
      });
    }
    var moduleName = scope ? scope.module : null, controllerName;
    
    function gather(prop, obj, depth, useObjAsVal) {
      // 'hasOwnProperty' and such are usually just noise, leave them
      // out when no prefix is provided.
      //if (query.omitObjectPrototype !== false && obj == srv.cx.protos.Object && !word) return;
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) != 0) return;

      var val = null;
      if (obj) val =  useObjAsVal ? obj : obj.props[prop];
      if (!val) val = infer.ANull;

      for (var i = 0; i < completions.length; ++i) {
        var c = completions[i];
        if ((wrapAsObjs ? c.name : c) == prop) {
          if (c.type === '?' || c.type === '[?]') {
            infer.resetGuessing();
            var type = val.getType();            
            //if (query.types)
            c.type= infer.toString(type);
          }
          return;
        }
      }
      var rec = wrapAsObjs ? {name: prop} : prop;
      completions.push(rec);

      //if (query.types || query.docs || query.urls || query.origins) {
        infer.resetGuessing();
        var type = val.getType();
        rec.guess = infer.didGuess();
        //if (query.types)
          rec.type = infer.toString(type);
        //if (query.docs)
          maybeSet(rec, "doc", val.doc || type && type.doc);
        //if (query.urls)
          maybeSet(rec, "url", val.url || type && type.url);
        //if (query.origins)
          maybeSet(rec, "origin", val.origin || type && type.origin);
      //}
      if (query.depths) rec.depth = depth;
      if (moduleName) rec.module = moduleName;
      if (controllerName) rec.controller = controllerName;
    }

   for ( var i = 0; i < angularTypes.length; i++) {
    var angularType = angularTypes[i];
 
      switch (angularType) {
      case 'module':
        // find modules
        visitModules(_angular, files, function(moduleName, module) {
          createCompletionIfMatch(moduleName, module, moduleName, 'module')
        });
        break;
      case 'controller':
        // find controller
        visitControllers(_angular, files, moduleName, function(name, node,
            fnType, scopeArg) {
          createCompletionIfMatch(name, fnType, moduleName, 'controller')
        });
        break;
      case 'directive':
        // find directives for a module
        completionDirectives(_angular, files, moduleName);
        break;
      case 'directives':
        // find directives for the all modules.
        for (var moduleName in _angular.modules) {
          completionDirectives(_angular, files, moduleName);
        }
        break;
      case 'filter':
        // find filters for a module
        visitFilters(_angular, files, moduleName, function(name, node,
            fnType) {
          createCompletionIfMatch(name, fnType, moduleName, 'filter')
        });
        break;  
      case 'factory':
        // find factories for a module
        visitFactories(_angular, files, moduleName, function(name, node,
            fnType) {
          createCompletionIfMatch(name, fnType, moduleName, 'factory')
        });
        break;   
      case 'provider':
        // find providers for a module
        visitProviders(_angular, files, moduleName, function(name, node,
            fnType) {
          createCompletionIfMatch(name, fnType, moduleName, 'provider')
        });
        break;
      case 'service':
        // find services for a module
        visitServices(_angular, files, moduleName, function(name, node,
            fnType) {
          createCompletionIfMatch(name, fnType, moduleName, 'service')
        });
        break;                   
      default:
  
        var controllers = scope.controllers, scopeProps = scope.props;
        if (controllers) {
          for ( var j = 0; j < controllers.length; j++) {
            controllerName = controllers[j];
            var scopeCtrl = getScopeController(_angular, files, moduleName,
                controllerName);
            if (scopeCtrl) {
              if (context) {
                var root = scopeCtrl;
                for ( var i = 0; i < context.length; i++) {
                  var prop = context[i];
                  if (scopeProps && scopeProps[prop] && scopeProps[prop].repeat) {
                    var arrProp = scopeProps[prop].repeat; // case when ngRepeat;
                    root = getArrType(root, arrProp);
                  } else {
                    root = getType(root, prop)
                  }
                  if (!root)
                    break;
                }
                if (root) infer.forAllPropertiesOf(root, gather);
              } else {
                if (scopeProps) {
                  for ( var prop in scopeProps) {
                    if (startsWithString(prop, word)) {
                      var obj = null;
                      if (scopeProps[prop].repeat) {
                        var arrProp = scopeProps[prop].repeat; // case when ngRepeat;
                        obj = getArrType(scopeCtrl, arrProp);                      
                      }
                      gather(prop, obj, null, true);
                    }
                  }
                }
                
                var scopeType = scopeCtrl.getType(true);
                if (scopeType) infer.forAllPropertiesOf(scopeType, gather);
                else {
                  findModels(scopeCtrl, function(forward) {
                    var prop = forward.prop;
                    if (prop && forward.type) {
                      gather(prop, forward.type, null, true);
                    }
                  });
                }
              }
            }
          }
        }
        
        if (!context && scopeProps) {
          // case when ngModel defines a simple variable (which cannot be defined in the $scope).
          for ( var prop in scopeProps) {
              if (!scopeProps[prop].repeat) gather(prop, null, null, true);
          }
        }
        // $rootScope of module
        if (moduleName) {
          var module = getModule(_angular, files, moduleName)
          if (module && module.rootScope) {
            infer.forAllPropertiesOf(module.rootScope, gather);
            module.rootScope.guessProperties(gather);
          }
        }
        break;
      }
    }
    return result;
  }
  
  function createCompletion(name, node, scope, query, module, angularType) {
          var completion = {"name" : name};
          if (node) {
                  var type = infer.toString(node);
                  if (type) completion.type = type;
                  var origin = node.origin;
                  if (origin) completion.origin = origin;
          } else {
                  completion.type = "?";
          }
          if (module) completion.module = module;
          if (angularType) completion.angularType = angularType;     
          return completion;
  }
  
  function findDef(_angular, files, expression, scope, angularTypes, query) {
          var angularType = angularTypes[0];
          var node = null;
          switch (angularType) {
                case 'module':
                        // find modules
                        visitModules(_angular, files, function(moduleName, module) {
                                if (moduleName == expression) {
                                        node = module.originNode;
                                        return true;
                                }
                        });               
                        break;
                case 'controller':
                  var moduleName = scope ? scope.module : null;
                        visitControllers(_angular, files, moduleName, function(name, n, fnType, scopeArg) {
                                if (name == expression) {
                                        node = n;
                                        return true;
                                }
                        });
                        break;
                case 'directive':
                  var moduleName = scope ? scope.module : null;
                  visitDirectives(_angular, files, moduleName, function(name, n, fnType) {
                    if (name == expression) {
                      node = n;
                      return true;
                    }
                  });
                  break; 
                case 'filter':
                  var moduleName = scope ? scope.module : null;
                  visitFilters(_angular, files, moduleName, function(name, n, fnType) {
                    if (name == expression) {
                      node = n;
                      return true;
                    }
                  });
                  break;  
                case 'factory':
                  var moduleName = scope ? scope.module : null;
                  visitFactories(_angular, files, moduleName, function(name, n, fnType) {
                    if (name == expression) {
                      node = n;
                      return true;
                    }
                  });
                  break;
                case 'provider':
                  var moduleName = scope ? scope.module : null;
                  visitProviders(_angular, files, moduleName, function(name, n, fnType) {
                    if (name == expression) {
                      node = n;
                      return true;
                    }
                  });
                  break;       
                case 'service':
                  var moduleName = scope ? scope.module : null;
                  visitServices(_angular, files, moduleName, function(name, n, fnType) {
                    if (name == expression) {
                      node = n;
                      return true;
                    }
                  });
                  break;                  
                default:
                  var moduleName = scope.module;
                var controllerName = 'TODO';
                findModels(_angular, files, moduleName, controllerName, function(forward) {
                                var prop = forward.prop;
                                if (prop == expression) {
                                        node = forward;
                                        return true;
                                }
                        });
                        break;
          }
          if (node) {
                  return {file: node.sourceFile.name, start: node.start, end: node.end};
          }
          return {};
  }
  


      function findType(_angular, files, expression, scope, angularTypes, query) {
        var angularType = angularTypes[0];
        var type, name, origin = null;
        switch (angularType) {
        case 'module':
          // find modules
          visitModules(_angular, files, function(moduleName, module) {
            if (moduleName == expression) {
              name = moduleName;
              type = module;
              return true;
            }
          });
          break;
        case 'controller':
          var moduleName = scope.module;
          visitControllers(_angular, files, moduleName, function(n, node,
              fnType, scopeArg) {
            if (n == expression) {
              name = n;
              type = fnType;
              return true;
            }
          });
          break;
        case 'directive':
          var moduleName = scope.module;
          visitDirectives(_angular, files, moduleName, function(n, node,
              fnType) {
            if (n == expression) {
              name = n;
              type = fnType;
              return true;
            }
          });
          break;
          
        default:
          var moduleName = scope.module;
          var controllerName = 'TODO';
          findModels(_angular, files, moduleName, controllerName, function(
              forward) {
            var prop = forward.prop;
            if (prop == expression) {
              name = prop;
              type = forward.type;
              return true;
            }
          });
          break;
        }
        if (type) {
          return {
            type : infer.toString(type),
            name : name,
            origin : type.origin
          }
        }
        return {};
      }
  
  
  function ternError(msg) {
    var err = new Error(msg);
    err.name = "TernError";
    return err;
  }
  
});
